<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #canvas {
      background: #000;
    }
  </style>
</head>
<body>
  <canvas id="canvas">
  <!-- 
    图形转换都有哪些方法：
      scale() 缩放当前绘图至更大或更小
      rotate() 旋转当前绘图
      translate() 重新映射画布上的 (0,0) 位置
      transform() 替换绘图的当前转换矩阵
      setTransform() 将当前转换重置为单位矩阵，然后运行 transform()
   -->
   <script>
      var canvas = document.getElementById("canvas");
      var context = canvas.getContext("2d");
      var cx = canvas.width = 400;
      var cy = canvas.height = 400;

      // 缩放
      // context.strokeStyle = 'white';
      // context.strokeRect(5,5,50,25);
      // context.scale(2,2);
      // context.strokeRect(5,5,50,25);
      // context.scale(2,2);
      // context.strokeRect(5,5,50,25);
      /* 可以看到，在设置 scale() 方法之后再设置的矩形，无论是线条的宽度还是坐标的位置，都被放大了。并且 scale() 的效果是可以叠加的，也就是说，我们在上面的例子中使用了两次 scale(2,2) 那么，最后一个矩形相对于第一个矩形长和宽，以及坐标的位置就放大了 4 倍。 */

      // 旋转
      // context.fillStyle = "white";
      // context.rotate(20 * Math.PI / 180);
      // context.fillRect(70, 30, 200, 100);

      // 图像绘制
      /* 
        drawImage()	向画布上绘制图像、画布或视频

        context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);

        img：规定要使用的图像、画布或视频
        sx：可选。开始剪切的 x 坐标位置
        sy：可选。开始剪切的 y 坐标位置
        swidth：可选。被剪切图像的宽度
        sheight：可选。被剪切图像的高度
        x：在画布上放置图像的 x 坐标位置
        y：在画布上放置图像的 y 坐标位置
        width：可选。要使用的图像的宽度（伸展或缩小图像）
        height：可选。要使用的图像的高度（伸展或缩小图像）
       */
   </script>
</body>
</html>